['../evaluation_tmp.py', '5000']
size: 5472
data size: 5000, nu: 0.2, gamma: 1
============ 1. Fold of CV ============
1) Incremental OCSVM
None
Confusion matrix:
Prediction    -1     1
Target                
-1          3441  1084
 1            47   428
precision: 0.283068783069, recall: 0.901052631579, f1-score: 0.430800201309
Number of support vectors: 4
-----------
2) cvxopt-OCSVM
Confusion matrix:
Prediction    -1    1
Target               
-1          3865  660
 1            52  423
precision: 0.390581717452, recall: 0.890526315789, f1-score: 0.543003851091
Number of support vectors: 121
---------
3) sklearn-OCSVM
Confusion matrix:
Prediction    -1    1
Target               
-1          3870  655
 1            52  423
Number of support vectors: 803
precision: 0.392393320965, recall: 0.890526315789, f1-score: 0.544752092724
Wrote profile results to evaluation_tmp.py.lprof
Timer unit: 1e-06 s

Total time: 123.24 s
File: ../ocsvm.py
Function: increment at line 97

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    97                                               @profile
    98                                               def increment(self, Xc, init_ac=0, break_count=-1):
    99                                           
   100                                                   # epsilon
   101         1            5      5.0      0.0          e = self._data._e
   102         1            4      4.0      0.0          mu = 0
   103         1            3      3.0      0.0          imin = None
   104                                           
   105                                                   # initialize existing X, coefficients a, C
   106         1            8      8.0      0.0          X_origin = self._data.X()
   107         1            8      8.0      0.0          K_X_origin = self._data.K_X()
   108         1            5      5.0      0.0          n_data = X_origin.shape[0]
   109         1            4      4.0      0.0          n_feature = X_origin.shape[1]
   110                                           
   111         1            7      7.0      0.0          C = self._data.C()
   112         1            6      6.0      0.0          a_origin = self._data.alpha()
   113                                           
   114                                                   # number of new incremental points
   115         1            4      4.0      0.0          n_new = Xc.shape[0]
   116                                           
   117                                                   # number of all (new and existing) points
   118         1            3      3.0      0.0          n_all = n_data + n_new
   119                                           
   120                                                   # concatenate all new points with all existing points
   121         1            9      9.0      0.0          X = empty((n_new + n_data, n_feature))
   122         1          101    101.0      0.0          X[0:n_new, :] = Xc
   123         1           30     30.0      0.0          X[n_new:, :] = X_origin
   124                                           
   125                                                   # create gram matrix for all new and existing points
   126                                           
   127                                                   # create of all data points
   128         1            5      5.0      0.0          if K_X_origin == None:
   129         1      1376036 1376036.0      1.1              K_X = self.gram(X)
   130                                                   # create gram matrix for new points and add to existing ones
   131                                                   else:
   132                                                       K_X = empty((n_all, n_all))
   133                                                       K_X[n_new:, n_new:] = K_X_origin
   134                                                       K_X_new = self.gram(Xc, X_origin)
   135                                                       K_X[0:n_new, :] = K_X_new
   136                                                       K_X[:, 0:n_new] = K_X_new.T
   137                                           
   138                                                   # creating coefficient vector alpha for all data points
   139         1           29     29.0      0.0          a = empty(n_all)
   140         1           15     15.0      0.0          a[n_new:] = a_origin
   141         1           17     17.0      0.0          a[:n_new] = init_ac
   142                                           
   143                                                   # creating gradient vector
   144         1           17     17.0      0.0          g = zeros(n_all)
   145                                           
   146                                                   # create sensitivity vector
   147         1            6      6.0      0.0          gamma = empty(n_all)
   148         1            4      4.0      0.0          check_gradient = False
   149                                                   # loop through all new points to increment
   150      3158        10721      3.4      0.0          for x_count in range(n_new):
   151                                                       #print "--------- START %s ---------" % x_count
   152                                           
   153      3157        10227      3.2      0.0              if x_count == break_count:
   154                                                           self._data.set_X(X)
   155                                                           self._data.set_alpha(a)
   156                                                           self._data.set_C(C)
   157                                                           self._data.set_K_X(K_X)
   158                                                           self.rho()
   159                                                           return False
   160                                           
   161                                                       # initialize X, a, C, g, indices, kernel values
   162      3157        10512      3.3      0.0              start_origin = n_new - x_count
   163      3157        10125      3.2      0.0              start_new = start_origin - 1
   164                                           
   165      3157        10271      3.3      0.0              if x_count == 0:
   166         1            3      3.0      0.0                  inds = []
   167         1            3      3.0      0.0                  indr = []
   168         1            3      3.0      0.0                  inde = []
   169         1            3      3.0      0.0                  indo = []
   170       844         2689      3.2      0.0                  for i in range(n_new, n_all):
   171       843         4333      5.1      0.0                      if e < a[i] < C - e:
   172       625         2254      3.6      0.0                          inds.append(i)
   173                                                               else:
   174       218          791      3.6      0.0                          indr.append(i)
   175       218          913      4.2      0.0                          if a[i] <= e:
   176                                                                       indo.append(i)
   177                                                                   else:
   178       218          790      3.6      0.0                              inde.append(i)
   179                                           
   180         1            6      6.0      0.0                  ls = len(inds)                               # support vectors length
   181         1            3      3.0      0.0                  lr = len(indr)                               # error and non-support vectors length
   182         1            3      3.0      0.0                  le = len(inde)                               # error vectors lenght
   183         1            3      3.0      0.0                  lo = len(indo)
   184                                                           # calculate mu according to KKT-conditions
   185         1          114    114.0      0.0                  mu = - K_X[inds[0], :][start_origin:].dot(a[start_origin:])
   186                                                           # calculate gradient of error and non-support vectors
   187         1            3      3.0      0.0                  if lr > 0:
   188         1        77689  77689.0      0.1                      g[indr] = K_X[indr, :][:, start_origin:].dot(a[start_origin:]) + mu
   189                                           
   190      3157        13834      4.4      0.0              c_inds = [start_new] + inds
   191                                                       # only calculate gradient if there are support vectors
   192      3157        10293      3.3      0.0              if ls > 0:
   193      3157       235848     74.7      0.2                  gc = K_X[start_new, start_origin:].dot(a[start_origin:]) + mu
   194                                                       else:
   195                                                           print "No support vectors to train!"
   196                                                           sys.exit()
   197      3157        12481      4.0      0.0              ac = a[start_new]
   198                                           
   199      3157        10571      3.3      0.0              if x_count == 0:
   200         1          743    743.0      0.0                  Q = ones((ls+1, ls+1))
   201         1            4      4.0      0.0                  Q[0, 0] = 0
   202       626         2349      3.8      0.0                  inds_row = [[i] for i in inds]
   203         1        45957  45957.0      0.0                  Q[1:, 1:] = K_X[inds_row, inds]
   204         1            5      5.0      0.0                  try:
   205         1       114423 114423.0      0.1                      R = inv(Q)
   206                                                           except np.linalg.linalg.LinAlgError:
   207                                                               x = 1e-11
   208                                                               found = False
   209                                                               print "singular matrix"
   210                                                               while not found:
   211                                                                   try:
   212                                                                       R = inv(Q + diag(ones(ls+1) * x))
   213                                                                       found = True
   214                                                                   except np.linalg.linalg.LinAlgError:
   215                                                                       x = x*10
   216      3157        10424      3.3      0.0              loop_count = 1
   217                                                       #print "gc: %s, ac: %s" % (gc, ac)
   218      8142        56774      7.0      0.0              while gc < e and ac < C - e:
   219      5868        20474      3.5      0.0                  if ls == 0: check_gradient = True
   220                                                           #print "-------------------- incremental %s-%s ---------" % (x_count, loop_count)
   221                                           
   222      5868        19687      3.4      0.0                  if ls > 0:
   223      5868       276655     47.1      0.2                      n = K_X[start_new, :][c_inds]
   224      5868       340779     58.1      0.3                      beta = - R.dot(n)
   225      5868        29891      5.1      0.0                      betas = beta[1:]
   226                                           
   227                                                           # calculate gamma
   228      5868        20785      3.5      0.0                  if lr > 0 and ls > 0:
   229      5868     98000368  16700.8     79.5                      gamma_tmp = K_X[:, c_inds][start_new:]
   230      5868       141248     24.1      0.1                      gamma_tmp[:, 0] = 1
   231      5868      1622428    276.5      1.3                      gamma[start_new:] = gamma_tmp.dot(beta) + K_X[start_new, :][start_new:]
   232      5868        31030      5.3      0.0                      gammac = gamma[start_new]
   233                                           
   234                                                           elif ls > 0:
   235                                                               # empty R set
   236                                                               gammac = K_X[start_new, :][c_inds].dot(beta) + 1
   237                                           
   238                                                           else:
   239                                                               # empty S set
   240                                                               gammac = 1
   241                                                               gamma[indr] = 1
   242                                                               #gamma[indo] = -1
   243                                           
   244                                                           # accounting
   245                                                           #case 1: Some alpha_i in S reaches a bound
   246      5868        21768      3.7      0.0                  if ls > 0:
   247                                                               # only consider non-zero coefficient sensitivity betas
   248      5868        74352     12.7      0.1                      IS_plus = betas > e
   249      5868        52444      8.9      0.0                      IS_minus = betas < - e
   250                                                               # look for greatest increment according to sensitivity
   251      5868       144999     24.7      0.1                      gsmax = ones(ls)*inf
   252      5868       338375     57.7      0.3                      gsmax[IS_plus] = -a[inds][IS_plus] + C
   253      5868       240368     41.0      0.2                      gsmax[IS_minus] = - a[inds][IS_minus]
   254      5868        46216      7.9      0.0                      gsmax = divide(gsmax, betas)
   255                                                               # find minimum and index of it
   256      5868       166386     28.4      0.1                      gsmin = min(absolute(gsmax))
   257      5868        96412     16.4      0.1                      ismin = where(absolute(gsmax) == gsmin)[0][0]
   258                                                           else: gsmin = inf
   259                                                           #case 2: Some g_i in E reaches zero
   260      5868        21253      3.6      0.0                  if le > 0:
   261      5868       862197    146.9      0.7                      gamma_inde = gamma[inde]
   262      5868       808827    137.8      0.7                      g_inde = g[inde]
   263                                                               # only consider positive margin sensitivity for points in E
   264      5868        57980      9.9      0.0                      Ie_plus = gamma_inde > e
   265      5868        81408     13.9      0.1                      if len(g_inde[Ie_plus]) > 0:
   266      5209       166912     32.0      0.1                          gec = divide(-g_inde[Ie_plus], gamma_inde[Ie_plus])
   267                                                                   # only consider positive increment weights
   268      5209        72927     14.0      0.1                          gec[gec <= 0] = inf
   269                                                                   # find minimum and index of it
   270      5209       386713     74.2      0.3                          gemin = min(gec)
   271      5209        28031      5.4      0.0                          if gemin < inf:
   272      5209        85633     16.4      0.1                              iemin = where(gec == gemin)[0][0]
   273       659         2392      3.6      0.0                      else: gemin = inf
   274                                                           else: gemin = inf
   275                                                           #case 2: Some g_i in O reaches zero
   276      5868        21290      3.6      0.0                  if lo > 0 and ls > 0:
   277      4993      1064912    213.3      0.9                      gamma_indo = gamma[indo]
   278      4993      1048400    210.0      0.9                      g_indo = g[indo]
   279      4993        52516     10.5      0.0                      Io_minus = gamma_indo < - e
   280      4993        79944     16.0      0.1                      if len(g_indo[Io_minus]) > 0:
   281      4508       168985     37.5      0.1                          goc = divide(-g_indo[Io_minus], gamma_indo[Io_minus])
   282      4508        59215     13.1      0.0                          goc[goc <= 0] = inf
   283      4508       110384     24.5      0.1                          goc[g_indo[Io_minus] < 0] = inf
   284      4508       300930     66.8      0.2                          gomin = min(goc)
   285      4508        23341      5.2      0.0                          if gomin < inf:
   286      4238        71616     16.9      0.1                              iomin = where(goc == gomin)[0][0]
   287       485         1798      3.7      0.0                      else: gomin = inf
   288       875         3197      3.7      0.0                  else: gomin = inf
   289                                           
   290                                                           # case 3: gc becomes zero => algorithm converges
   291      5868        34660      5.9      0.0                  if gammac > e: gcmin = - gc/gammac
   292       668         2370      3.5      0.0                  else: gcmin = inf
   293                                           
   294                                                           # case 4: ac becomes an error vector => algorithm converges
   295      5868        30543      5.2      0.0                  if ls > 0: gacmin = C - ac
   296                                                           else: gacmin = inf
   297                                           
   298                                                           # determine minimum largest increment
   299      5868        26153      4.5      0.0                  all_deltas = [gsmin, gemin, gomin, gcmin, gacmin]
   300      5868        31809      5.4      0.0                  gmin = min(all_deltas)
   301      5868       122111     20.8      0.1                  imin = where(all_deltas == gmin)[0][0]
   302                                                           # update a, g
   303      5868        21234      3.6      0.0                  if ls > 0:
   304      5868        30090      5.1      0.0                      mu += beta[0]*gmin
   305      5868        22960      3.9      0.0                      ac += gmin
   306      5868       418363     71.3      0.3                      a[inds] += betas*gmin
   307                                                           else:
   308                                                               mu += gmin
   309      5868        21721      3.7      0.0                  if lr > 0:
   310      5868      5253890    895.3      4.3                      g[indr] += gamma[indr] * gmin
   311      5868        28894      4.9      0.0                  gc += gammac * gmin
   312      5868        31335      5.3      0.0                  if imin == 0: # min = gsmin => move k from s to r
   313                                                               # if there are more than 1 minimum, just take 1
   314      2801       112550     40.2      0.1                      ak = a[inds][ismin]
   315                                                               # delete the elements from X,a and g
   316                                                               # => add it to the end of X,a,g
   317      2801        11846      4.2      0.0                      ind_del = inds[ismin]
   318      2801       140200     50.1      0.1                      inds.remove(ind_del)
   319      2801        16355      5.8      0.0                      c_inds = [start_new] + inds
   320      2801        12487      4.5      0.0                      indr.append(ind_del)
   321      2801        13402      4.8      0.0                      if ak < e:
   322      1508         6112      4.1      0.0                          indo.append(ind_del)
   323      1508         5581      3.7      0.0                          lo += 1
   324                                                               else:
   325      1293         5312      4.1      0.0                          inde.append(ind_del)
   326      1293         4794      3.7      0.0                          le += 1
   327                                           
   328      2801         9942      3.5      0.0                      lr += 1
   329                                                               #decrement R, delete row ismin and column ismin
   330      2801         9834      3.5      0.0                      if ls > 2:
   331      2801        14243      5.1      0.0                          ismin += 1
   332      2801       345579    123.4      0.3                          R_new = zeros((ls,ls))
   333      2801       334092    119.3      0.3                          R_new[0:ismin, 0:ismin] = R[0:ismin, 0:ismin]
   334      2801        88482     31.6      0.1                          R_new[ismin:, 0:ismin] = R[ismin+1:,0:ismin]
   335      2801        77860     27.8      0.1                          R_new[0:ismin, ismin:] = R[0:ismin, ismin+1:]
   336      2801       119513     42.7      0.1                          R_new[ismin:, ismin:] = R[ismin+1:, ismin+1:]
   337      2801        23443      8.4      0.0                          betak = zeros(ls)
   338      2801        24630      8.8      0.0                          betak[:ismin] = R[ismin, :ismin]
   339      2801        25341      9.0      0.0                          betak[ismin:] = R[ismin, ismin+1:]
   340      2801      2509990    896.1      2.0                          R_new -= outer(betak, betak)/R[ismin,ismin]
   341      2801        13673      4.9      0.0                          R = R_new
   342                                                               elif ls == 2:
   343                                                                   R = ones((2, 2))
   344                                                                   R[1,1] = 0
   345                                                                   R[0,0] = -1
   346                                                               else:
   347                                                                   R = inf
   348      2801        11133      4.0      0.0                      ls -= 1
   349                                           
   350      3067        14147      4.6      0.0                  elif imin == 1:
   351                                                               # delete the elements from X,a and g => add it to the end of X,a,g
   352      1672       237087    141.8      0.2                      ind_del = np.asarray(inde)[Ie_plus][iemin]
   353      1672         6327      3.8      0.0                      if ls > 0:
   354      1672        77007     46.1      0.1                          nk = K_X[ind_del, :][[ind_del] + inds]
   355      1672       170663    102.1      0.1                          betak = - R.dot(nk)
   356      1672       117541     70.3      0.1                          k = 1 - nk.dot(R).dot(nk)
   357      1672        22076     13.2      0.0                          betak1 = ones(ls + 2)
   358      1672         9447      5.7      0.0                          betak1[:-1] = betak
   359      1672         6960      4.2      0.0                          R_old = R
   360      1672       614660    367.6      0.5                          R = 1/k * outer(betak1, betak1)
   361      1672       505969    302.6      0.4                          R[:-1,:-1] += R_old
   362                                                               else:
   363                                                                   R = ones((2, 2))
   364                                                                   R[1,1] = 0
   365                                                                   R[0,0] = -1
   366      1672         9698      5.8      0.0                      inds.append(ind_del)
   367      1672        11860      7.1      0.0                      c_inds = [start_new] + inds
   368      1672       722293    432.0      0.6                      indr.remove(ind_del)
   369      1672       434310    259.8      0.4                      inde.remove(ind_del)
   370      1672         6500      3.9      0.0                      ls += 1
   371      1672         6484      3.9      0.0                      lr -= 1
   372      1672         6242      3.7      0.0                      le -= 1
   373                                           
   374      1395         6231      4.5      0.0                  elif imin == 2: # min = gemin | gomin => move k from r to s
   375                                           
   376                                                               # delete the elements from X,a and g => add it to the end of X,a,g
   377       512       109890    214.6      0.1                      ind_del = np.asarray(indo)[Io_minus][iomin]
   378       512         1974      3.9      0.0                      if ls > 0:
   379       512         6497     12.7      0.0                          nk = ones(ls+1)
   380       512        13117     25.6      0.0                          nk[1:] = K_X[ind_del,:][inds]
   381       512        10520     20.5      0.0                          betak = - R.dot(nk)
   382       512         9281     18.1      0.0                          k = 1 - nk.dot(R).dot(nk)
   383       512         5737     11.2      0.0                          betak1 = ones(ls+2)
   384       512         2573      5.0      0.0                          betak1[:-1] = betak
   385       512         2058      4.0      0.0                          R_old = R
   386       512        32016     62.5      0.0                          R = 1/k * outer(betak1, betak1)
   387       512        17410     34.0      0.0                          R[:-1,:-1] += R_old
   388                                                               else:
   389                                                                   R = ones((2, 2))
   390                                                                   R[1,1] = 0
   391                                                                   R[0,0] = -1
   392                                           
   393       512       202125    394.8      0.2                      indo.remove(ind_del)
   394       512       399748    780.8      0.3                      indr.remove(ind_del)
   395       512         2328      4.5      0.0                      inds.append(ind_del)
   396       512         2722      5.3      0.0                      c_inds = [start_new] + inds
   397       512         1964      3.8      0.0                      lo -= 1
   398       512         1912      3.7      0.0                      lr -= 1
   399       512         1936      3.8      0.0                      ls += 1
   400       883         3989      4.5      0.0                  elif imin == 3:
   401         6           24      4.0      0.0                      break
   402                                                           else:
   403       877         3300      3.8      0.0                      break
   404      4985        17615      3.5      0.0                  loop_count += 1
   405                                           
   406      3157        12357      3.9      0.0              a[start_new] = ac
   407      3157        12088      3.8      0.0              g[start_new] = gc
   408      3157        14735      4.7      0.0              if ac < e:
   409      2274        10258      4.5      0.0                  indr.append(start_new)
   410      2274         9462      4.2      0.0                  indo.append(start_new)
   411      2274         8474      3.7      0.0                  lr += 1
   412      2274         7438      3.3      0.0                  lo += 1
   413       883         4346      4.9      0.0              elif ac > C - e:
   414       877         4365      5.0      0.0                  indr.append(start_new)
   415       877         3728      4.3      0.0                  inde.append(start_new)
   416       877         3330      3.8      0.0                  lr += 1
   417       877         2894      3.3      0.0                  le += 1
   418                                                       else:
   419         6           30      5.0      0.0                  inds.append(start_new)
   420         6           24      4.0      0.0                  g[start_new] = 0
   421         6           25      4.2      0.0                  if len(inds) == 1:
   422                                                               R = ones((2, 2))
   423                                                               R[1,1] = 0
   424                                                               R[0,0] = -1
   425                                                           else:
   426         6           33      5.5      0.0                      if R.shape[0] != len(inds) + 1:
   427         6           71     11.8      0.0                          nk = ones(ls+1)
   428         6          131     21.8      0.0                          nk[1:] = K_X[start_new, :][inds[:-1]]
   429         6           73     12.2      0.0                          betak = - R.dot(nk)
   430         6           79     13.2      0.0                          k = 1 - nk.dot(R).dot(nk)
   431         6           66     11.0      0.0                          betak1 = ones(ls + 2)
   432         6           30      5.0      0.0                          betak1[:-1] = betak
   433         6           24      4.0      0.0                          R_old = R
   434         6          228     38.0      0.0                          R = 1/k * outer(betak1, betak1)
   435         6           89     14.8      0.0                          R[:-1,:-1] += R_old
   436                                           
   437         6           19      3.2      0.0                  ls += 1
   438                                                    # update X, a
   439         1           16     16.0      0.0          self._data.set_X(X)
   440         1            8      8.0      0.0          self._data.set_alpha(a)
   441         1            8      8.0      0.0          self._data.set_C(C)
   442         1            9      9.0      0.0          self._data.set_K_X(K_X)
   443         1         1359   1359.0      0.0          print self.rho()


*** PROFILER RESULTS ***
incremental_ocsvm (../evaluation_tmp.py:185)
function called 1 times

         170683 function calls in 129.092 seconds

   Ordered by: cumulative time, internal time, call count
   List reduced from 150 to 40 due to restriction <40>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000  129.092  129.092 evaluation_tmp.py:185(incremental_ocsvm)
        1    0.000    0.000  125.366  125.366 line_profiler.py:95(wrapper)
        1  117.432  117.432  125.365  125.365 ocsvm.py:97(increment)
        1    0.001    0.001    3.726    3.726 ocsvm.py:35(fit)
        1    0.091    0.091    3.725    3.725 ocsvm.py:62(alpha)
        1    0.000    0.000    3.543    3.543 coneprog.py:4159(qp)
        1    0.006    0.006    3.543    3.543 coneprog.py:1441(coneqp)
       13    0.000    0.000    3.301    0.254 coneprog.py:1984(kktsolver)
       13    0.041    0.003    3.301    0.254 misc.py:1389(factor)
       13    2.069    0.159    2.069    0.159 {cvxopt.base.syrk}
     7169    1.865    0.000    1.865    0.000 {method 'remove' of 'list' objects}
    21466    1.780    0.000    1.780    0.000 {method 'dot' of 'numpy.ndarray' objects}
        2    0.000    0.000    1.427    0.713 ocsvm.py:58(gram)
        2    0.000    0.000    1.427    0.713 pairwise.py:1164(pairwise_kernels)
        2    0.000    0.000    1.427    0.713 pairwise.py:949(_parallel_pairwise)
        2    0.828    0.414    1.427    0.713 pairwise.py:740(rbf_kernel)
     4991    1.171    0.000    1.215    0.000 numeric.py:740(outer)
    21494    0.773    0.000    0.773    0.000 {min}
       13    0.749    0.058    0.749    0.058 {cvxopt.base.gemm}
        2    0.223    0.111    0.599    0.299 pairwise.py:136(euclidean_distances)
       26    0.432    0.017    0.432    0.017 {cvxopt.lapack.potrf}
        2    0.000    0.000    0.376    0.188 extmath.py:171(safe_sparse_dot)
        2    0.000    0.000    0.376    0.188 extmath.py:129(fast_dot)
        2    0.374    0.187    0.375    0.188 extmath.py:97(_fast_dot)
     5609    0.345    0.000    0.345    0.000 {numpy.core.multiarray.zeros}
    12174    0.027    0.000    0.343    0.000 numeric.py:167(asarray)
    12202    0.316    0.000    0.316    0.000 {numpy.core.multiarray.array}
      152    0.165    0.001    0.165    0.001 {cvxopt.base.gemv}
       25    0.001    0.000    0.155    0.006 misc.py:1489(solve)
       24    0.000    0.000    0.151    0.006 coneprog.py:2333(f4)
       24    0.000    0.000    0.150    0.006 coneprog.py:2291(f4_no_ir)
        1    0.000    0.000    0.114    0.114 linalg.py:404(inv)
        1    0.000    0.000    0.114    0.114 linalg.py:244(solve)
        1    0.106    0.106    0.106    0.106 {numpy.linalg.lapack_lite.dgesv}
     8581    0.039    0.000    0.087    0.000 numeric.py:1791(ones)
    21183    0.067    0.000    0.067    0.000 {numpy.core.multiarray.where}
       26    0.000    0.000    0.055    0.002 coneprog.py:1900(fG)
       26    0.000    0.000    0.055    0.002 misc.py:801(sgemv)
       50    0.043    0.001    0.043    0.001 {cvxopt.blas.trsv}
     8584    0.034    0.000    0.034    0.000 {numpy.core.multiarray.empty}



*** PROFILER RESULTS ***
cvxopt_ocsvm (../evaluation_tmp.py:181)
function called 1 times

         3752 function calls in 405.766 seconds

   Ordered by: cumulative time, internal time, call count
   List reduced from 123 to 40 due to restriction <40>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000  405.766  405.766 evaluation_tmp.py:181(cvxopt_ocsvm)
        1    0.046    0.046  405.766  405.766 ocsvm.py:35(fit)
        1    2.570    2.570  405.686  405.686 ocsvm.py:62(alpha)
        1    0.022    0.022  400.362  400.362 coneprog.py:4159(qp)
        1    0.020    0.020  400.340  400.340 coneprog.py:1441(coneqp)
       19    0.000    0.000  393.215   20.696 coneprog.py:1984(kktsolver)
       19    1.217    0.064  393.215   20.696 misc.py:1389(factor)
       19  300.029   15.791  300.029   15.791 {cvxopt.base.syrk}
       38   53.533    1.409   53.533    1.409 {cvxopt.lapack.potrf}
       19   37.716    1.985   37.716    1.985 {cvxopt.base.gemm}
      224    5.575    0.025    5.575    0.025 {cvxopt.base.gemv}
       37    0.002    0.000    4.735    0.128 misc.py:1489(solve)
       36    0.000    0.000    4.615    0.128 coneprog.py:2333(f4)
       36    0.001    0.000    4.615    0.128 coneprog.py:2291(f4_no_ir)
       38    0.000    0.000    1.897    0.050 coneprog.py:1900(fG)
       38    0.001    0.000    1.897    0.050 misc.py:801(sgemv)
        2    0.000    0.000    1.374    0.687 ocsvm.py:58(gram)
        2    0.000    0.000    1.374    0.687 pairwise.py:1164(pairwise_kernels)
        2    0.000    0.000    1.374    0.687 pairwise.py:949(_parallel_pairwise)
        2    0.792    0.396    1.374    0.687 pairwise.py:740(rbf_kernel)
        2    0.000    0.000    1.204    0.602 shape_base.py:177(vstack)
        2    1.204    0.602    1.204    0.602 {numpy.core.multiarray.concatenate}
       74    1.052    0.014    1.052    0.014 {cvxopt.blas.trsv}
       19    0.712    0.037    0.712    0.037 {cvxopt.blas.trsm}
        2    0.213    0.107    0.581    0.291 pairwise.py:136(euclidean_distances)
       19    0.000    0.000    0.413    0.022 coneprog.py:1847(fP)
       19    0.413    0.022    0.413    0.022 {cvxopt.base.symv}
        2    0.000    0.000    0.367    0.184 extmath.py:171(safe_sparse_dot)
        2    0.000    0.000    0.367    0.184 extmath.py:129(fast_dot)
        2    0.366    0.183    0.367    0.183 extmath.py:97(_fast_dot)
        2    0.000    0.000    0.208    0.104 twodim_base.py:220(diag)
        4    0.208    0.052    0.208    0.052 {numpy.core.multiarray.zeros}
        1    0.000    0.000    0.035    0.035 ocsvm.py:45(rho)
       18    0.015    0.001    0.023    0.001 misc.py:422(update_scaling)
      108    0.008    0.000    0.008    0.000 {cvxopt.misc_solvers.scale2}
      109    0.006    0.000    0.006    0.000 {cvxopt.misc_solvers.scale}
      131    0.006    0.000    0.006    0.000 {range}
      147    0.004    0.000    0.004    0.000 {cvxopt.blas.copy}
      329    0.004    0.000    0.004    0.000 {cvxopt.blas.axpy}
       38    0.004    0.000    0.004    0.000 {cvxopt.base.sqrt}



*** PROFILER RESULTS ***
sklearn_ocsvm (../evaluation_tmp.py:177)
function called 1 times

         61 function calls in 0.521 seconds

   Ordered by: cumulative time, internal time, call count

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.521    0.521 evaluation_tmp.py:177(sklearn_ocsvm)
        1    0.000    0.000    0.521    0.521 classes.py:941(fit)
        1    0.000    0.000    0.521    0.521 base.py:99(fit)
        1    0.000    0.000    0.520    0.520 base.py:211(_dense_fit)
        1    0.520    0.520    0.520    0.520 {sklearn.svm.libsvm.fit}
        1    0.000    0.000    0.000    0.000 validation.py:268(check_array)
        1    0.000    0.000    0.000    0.000 validation.py:43(_assert_all_finite)
        1    0.000    0.000    0.000    0.000 {method 'sum' of 'numpy.ndarray' objects}
        2    0.000    0.000    0.000    0.000 base.py:553(isspmatrix)
        5    0.000    0.000    0.000    0.000 {numpy.core.multiarray.array}
        2    0.000    0.000    0.000    0.000 sputils.py:116(_isinstance)
        1    0.000    0.000    0.000    0.000 base.py:193(_validate_targets)
        2    0.000    0.000    0.000    0.000 numeric.py:167(asarray)
        1    0.000    0.000    0.000    0.000 validation.py:126(_shape_repr)
        1    0.000    0.000    0.000    0.000 {method 'randint' of 'mtrand.RandomState' objects}
        1    0.000    0.000    0.000    0.000 numeric.py:1791(ones)
        1    0.000    0.000    0.000    0.000 shape_base.py:58(atleast_2d)
        1    0.000    0.000    0.000    0.000 {method 'join' of 'str' objects}
        3    0.000    0.000    0.000    0.000 validation.py:153(<genexpr>)
        1    0.000    0.000    0.000    0.000 getlimits.py:234(__init__)
        2    0.000    0.000    0.000    0.000 {numpy.core.multiarray.empty}
        1    0.000    0.000    0.000    0.000 {sklearn.svm.libsvm.set_verbosity_wrap}
        1    0.000    0.000    0.000    0.000 validation.py:503(check_random_state)
        1    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}
        2    0.000    0.000    0.000    0.000 numeric.py:237(asanyarray)
        1    0.000    0.000    0.000    0.000 validation.py:105(_num_samples)
        1    0.000    0.000    0.000    0.000 {method 'fill' of 'numpy.ndarray' objects}
        4    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}
        1    0.000    0.000    0.000    0.000 getlimits.py:259(max)
        3    0.000    0.000    0.000    0.000 {hasattr}
        3    0.000    0.000    0.000    0.000 {isinstance}
        1    0.000    0.000    0.000    0.000 base.py:203(_warn_from_fit_status)
        6    0.000    0.000    0.000    0.000 {len}
        1    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'index' of 'list' objects}
        2    0.000    0.000    0.000    0.000 {callable}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        0    0.000             0.000          profile:0(profiler)


