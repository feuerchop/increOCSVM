['../evaluation_tmp.py', '2000']
size: 5472
data size: 2000, nu: 0.2, gamma: 1
============ 1. Fold of CV ============
1) Incremental OCSVM
None
Confusion matrix:
Prediction    -1    1
Target               
-1          1529  262
 1            14  195
precision: 0.426695842451, recall: 0.933014354067, f1-score: 0.585585585586
Number of support vectors: 2
-----------
2) cvxopt-OCSVM
Confusion matrix:
Prediction    -1    1
Target               
-1          1507  284
 1            13  196
precision: 0.408333333333, recall: 0.937799043062, f1-score: 0.568940493469
Number of support vectors: 212
---------
3) sklearn-OCSVM
Confusion matrix:
Prediction    -1    1
Target               
-1          1526  265
 1            14  195
Number of support vectors: 321
precision: 0.423913043478, recall: 0.933014354067, f1-score: 0.582959641256
Wrote profile results to evaluation_tmp.py.lprof
Timer unit: 1e-06 s

Total time: 5.22865 s
File: ../ocsvm.py
Function: increment at line 97

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    97                                               @profile
    98                                               def increment(self, Xc, init_ac=0, break_count=-1):
    99                                           
   100                                                   # epsilon
   101         1            6      6.0      0.0          e = self._data._e
   102         1            3      3.0      0.0          mu = 0
   103         1            3      3.0      0.0          imin = None
   104                                           
   105                                                   # initialize existing X, coefficients a, C
   106         1            7      7.0      0.0          X_origin = self._data.X()
   107         1            7      7.0      0.0          K_X_origin = self._data.K_X()
   108         1            5      5.0      0.0          n_data = X_origin.shape[0]
   109         1            3      3.0      0.0          n_feature = X_origin.shape[1]
   110                                           
   111         1            7      7.0      0.0          C = self._data.C()
   112         1            6      6.0      0.0          a_origin = self._data.alpha()
   113                                           
   114                                                   # number of new incremental points
   115         1            3      3.0      0.0          n_new = Xc.shape[0]
   116                                           
   117                                                   # number of all (new and existing) points
   118         1            3      3.0      0.0          n_all = n_data + n_new
   119                                           
   120                                                   # concatenate all new points with all existing points
   121         1            9      9.0      0.0          X = empty((n_new + n_data, n_feature))
   122         1           42     42.0      0.0          X[0:n_new, :] = Xc
   123         1           14     14.0      0.0          X[n_new:, :] = X_origin
   124                                           
   125                                                   # create gram matrix for all new and existing points
   126                                           
   127                                                   # create of all data points
   128         1            4      4.0      0.0          if K_X_origin == None:
   129         1       217237 217237.0      4.2              K_X = self.gram(X)
   130                                                   # create gram matrix for new points and add to existing ones
   131                                                   else:
   132                                                       K_X = empty((n_all, n_all))
   133                                                       K_X[n_new:, n_new:] = K_X_origin
   134                                                       K_X_new = self.gram(Xc, X_origin)
   135                                                       K_X[0:n_new, :] = K_X_new
   136                                                       K_X[:, 0:n_new] = K_X_new.T
   137                                           
   138                                                   # creating coefficient vector alpha for all data points
   139         1           28     28.0      0.0          a = empty(n_all)
   140         1           14     14.0      0.0          a[n_new:] = a_origin
   141         1           13     13.0      0.0          a[:n_new] = init_ac
   142                                           
   143                                                   # creating gradient vector
   144         1           13     13.0      0.0          g = zeros(n_all)
   145                                           
   146                                                   # create sensitivity vector
   147         1            7      7.0      0.0          gamma = empty(n_all)
   148         1            4      4.0      0.0          check_gradient = False
   149                                                   # loop through all new points to increment
   150      1264         4520      3.6      0.1          for x_count in range(n_new):
   151                                                       #print "--------- START %s ---------" % x_count
   152                                           
   153      1263         4447      3.5      0.1              if x_count == break_count:
   154                                                           self._data.set_X(X)
   155                                                           self._data.set_alpha(a)
   156                                                           self._data.set_C(C)
   157                                                           self._data.set_K_X(K_X)
   158                                                           self.rho()
   159                                                           return False
   160                                           
   161                                                       # initialize X, a, C, g, indices, kernel values
   162      1263         4472      3.5      0.1              start_origin = n_new - x_count
   163      1263         4396      3.5      0.1              start_new = start_origin - 1
   164                                           
   165      1263         4427      3.5      0.1              if x_count == 0:
   166         1            4      4.0      0.0                  inds = []
   167         1            3      3.0      0.0                  indr = []
   168         1            3      3.0      0.0                  inde = []
   169         1            3      3.0      0.0                  indo = []
   170       338         1077      3.2      0.0                  for i in range(n_new, n_all):
   171       337         1738      5.2      0.0                      if e < a[i] < C - e:
   172        50          182      3.6      0.0                          inds.append(i)
   173                                                               else:
   174       287         1053      3.7      0.0                          indr.append(i)
   175       287         1203      4.2      0.0                          if a[i] <= e:
   176         1            3      3.0      0.0                              indo.append(i)
   177                                                                   else:
   178       286         1020      3.6      0.0                              inde.append(i)
   179                                           
   180         1            5      5.0      0.0                  ls = len(inds)                               # support vectors length
   181         1            4      4.0      0.0                  lr = len(indr)                               # error and non-support vectors length
   182         1            3      3.0      0.0                  le = len(inde)                               # error vectors lenght
   183         1            3      3.0      0.0                  lo = len(indo)
   184                                                           # calculate mu according to KKT-conditions
   185         1           79     79.0      0.0                  mu = - K_X[inds[0], :][start_origin:].dot(a[start_origin:])
   186                                                           # calculate gradient of error and non-support vectors
   187         1            4      4.0      0.0                  if lr > 0:
   188         1        28589  28589.0      0.5                      g[indr] = K_X[indr, :][:, start_origin:].dot(a[start_origin:]) + mu
   189                                           
   190      1263         5199      4.1      0.1              c_inds = [start_new] + inds
   191                                                       # only calculate gradient if there are support vectors
   192      1263         4391      3.5      0.1              if ls > 0:
   193      1263        38099     30.2      0.7                  gc = K_X[start_new, start_origin:].dot(a[start_origin:]) + mu
   194                                                       else:
   195                                                           print "No support vectors to train!"
   196                                                           sys.exit()
   197      1263         5061      4.0      0.1              ac = a[start_new]
   198                                           
   199      1263         4482      3.5      0.1              if x_count == 0:
   200         1           38     38.0      0.0                  Q = ones((ls+1, ls+1))
   201         1            4      4.0      0.0                  Q[0, 0] = 0
   202        51          179      3.5      0.0                  inds_row = [[i] for i in inds]
   203         1          485    485.0      0.0                  Q[1:, 1:] = K_X[inds_row, inds]
   204         1            3      3.0      0.0                  try:
   205         1          505    505.0      0.0                      R = inv(Q)
   206                                                           except np.linalg.linalg.LinAlgError:
   207                                                               x = 1e-11
   208                                                               found = False
   209                                                               print "singular matrix"
   210                                                               while not found:
   211                                                                   try:
   212                                                                       R = inv(Q + diag(ones(ls+1) * x))
   213                                                                       found = True
   214                                                                   except np.linalg.linalg.LinAlgError:
   215                                                                       x = x*10
   216      1263         4403      3.5      0.1              loop_count = 1
   217                                                       #print "gc: %s, ac: %s" % (gc, ac)
   218      3167        18975      6.0      0.4              while gc < e and ac < C - e:
   219      2430         8890      3.7      0.2                  if ls == 0: check_gradient = True
   220                                                           #print "-------------------- incremental %s-%s ---------" % (x_count, loop_count)
   221                                           
   222      2430         8650      3.6      0.2                  if ls > 0:
   223      2336        41655     17.8      0.8                      n = K_X[start_new, :][c_inds]
   224      2336        26438     11.3      0.5                      beta = - R.dot(n)
   225      2336        10825      4.6      0.2                      betas = beta[1:]
   226                                           
   227                                                           # calculate gamma
   228      2430         8538      3.5      0.2                  if lr > 0 and ls > 0:
   229      2336       389938    166.9      7.5                      gamma_tmp = K_X[:, c_inds][start_new:]
   230      2336        19504      8.3      0.4                      gamma_tmp[:, 0] = 1
   231      2336       106863     45.7      2.0                      gamma[start_new:] = gamma_tmp.dot(beta) + K_X[start_new, :][start_new:]
   232      2336         9859      4.2      0.2                      gammac = gamma[start_new]
   233                                           
   234        94          326      3.5      0.0                  elif ls > 0:
   235                                                               # empty R set
   236                                                               gammac = K_X[start_new, :][c_inds].dot(beta) + 1
   237                                           
   238                                                           else:
   239                                                               # empty S set
   240        94          314      3.3      0.0                      gammac = 1
   241        94        14974    159.3      0.3                      gamma[indr] = 1
   242                                                               #gamma[indo] = -1
   243                                           
   244                                                           # accounting
   245                                                           #case 1: Some alpha_i in S reaches a bound
   246      2430         8380      3.4      0.2                  if ls > 0:
   247                                                               # only consider non-zero coefficient sensitivity betas
   248      2336        21416      9.2      0.4                      IS_plus = betas > e
   249      2336        18306      7.8      0.4                      IS_minus = betas < - e
   250                                                               # look for greatest increment according to sensitivity
   251      2336        40236     17.2      0.8                      gsmax = ones(ls)*inf
   252      2336        61851     26.5      1.2                      gsmax[IS_plus] = -a[inds][IS_plus] + C
   253      2336        47365     20.3      0.9                      gsmax[IS_minus] = - a[inds][IS_minus]
   254      2336        16265      7.0      0.3                      gsmax = divide(gsmax, betas)
   255                                                               # find minimum and index of it
   256      2336        21880      9.4      0.4                      gsmin = min(absolute(gsmax))
   257      2336        30723     13.2      0.6                      ismin = where(absolute(gsmax) == gsmin)[0][0]
   258        94          330      3.5      0.0                  else: gsmin = inf
   259                                                           #case 2: Some g_i in E reaches zero
   260      2430         9008      3.7      0.2                  if le > 0:
   261      2430       173242     71.3      3.3                      gamma_inde = gamma[inde]
   262      2430       170986     70.4      3.3                      g_inde = g[inde]
   263                                                               # only consider positive margin sensitivity for points in E
   264      2430        22129      9.1      0.4                      Ie_plus = gamma_inde > e
   265      2430        24567     10.1      0.5                      if len(g_inde[Ie_plus]) > 0:
   266      2385        53247     22.3      1.0                          gec = divide(-g_inde[Ie_plus], gamma_inde[Ie_plus])
   267                                                                   # only consider positive increment weights
   268      2385        28796     12.1      0.6                          gec[gec <= 0] = inf
   269                                                                   # find minimum and index of it
   270      2385        88685     37.2      1.7                          gemin = min(gec)
   271      2385        12486      5.2      0.2                          if gemin < inf:
   272      2385        32542     13.6      0.6                              iemin = where(gec == gemin)[0][0]
   273        45          161      3.6      0.0                      else: gemin = inf
   274                                                           else: gemin = inf
   275                                                           #case 2: Some g_i in O reaches zero
   276      2430         9628      4.0      0.2                  if lo > 0 and ls > 0:
   277      2336       298071    127.6      5.7                      gamma_indo = gamma[indo]
   278      2336       292415    125.2      5.6                      g_indo = g[indo]
   279      2336        23155      9.9      0.4                      Io_minus = gamma_indo < - e
   280      2336        27382     11.7      0.5                      if len(g_indo[Io_minus]) > 0:
   281      2189        57290     26.2      1.1                          goc = divide(-g_indo[Io_minus], gamma_indo[Io_minus])
   282      2189        25928     11.8      0.5                          goc[goc <= 0] = inf
   283      2189        40225     18.4      0.8                          goc[g_indo[Io_minus] < 0] = inf
   284      2189        86766     39.6      1.7                          gomin = min(goc)
   285      2189        11573      5.3      0.2                          if gomin < inf:
   286      2180        30739     14.1      0.6                              iomin = where(goc == gomin)[0][0]
   287       147          553      3.8      0.0                      else: gomin = inf
   288        94          360      3.8      0.0                  else: gomin = inf
   289                                           
   290                                                           # case 3: gc becomes zero => algorithm converges
   291      2430        14809      6.1      0.3                  if gammac > e: gcmin = - gc/gammac
   292        52          191      3.7      0.0                  else: gcmin = inf
   293                                           
   294                                                           # case 4: ac becomes an error vector => algorithm converges
   295      2430        12896      5.3      0.2                  if ls > 0: gacmin = C - ac
   296        94          393      4.2      0.0                  else: gacmin = inf
   297                                           
   298                                                           # determine minimum largest increment
   299      2430        10785      4.4      0.2                  all_deltas = [gsmin, gemin, gomin, gcmin, gacmin]
   300      2430        12763      5.3      0.2                  gmin = min(all_deltas)
   301      2430        50256     20.7      1.0                  imin = where(all_deltas == gmin)[0][0]
   302                                                           # update a, g
   303      2430         9950      4.1      0.2                  if ls > 0:
   304      2336        12090      5.2      0.2                      mu += beta[0]*gmin
   305      2336         9993      4.3      0.2                      ac += gmin
   306      2336        76650     32.8      1.5                      a[inds] += betas*gmin
   307                                                           else:
   308        94          418      4.4      0.0                      mu += gmin
   309      2430         9702      4.0      0.2                  if lr > 0:
   310      2430      1302512    536.0     24.9                      g[indr] += gamma[indr] * gmin
   311      2430        12415      5.1      0.2                  gc += gammac * gmin
   312      2430        13547      5.6      0.3                  if imin == 0: # min = gsmin => move k from s to r
   313                                                               # if there are more than 1 minimum, just take 1
   314       978        15342     15.7      0.3                      ak = a[inds][ismin]
   315                                                               # delete the elements from X,a and g
   316                                                               # => add it to the end of X,a,g
   317       978         3943      4.0      0.1                      ind_del = inds[ismin]
   318       978         5308      5.4      0.1                      inds.remove(ind_del)
   319       978         4272      4.4      0.1                      c_inds = [start_new] + inds
   320       978         4235      4.3      0.1                      indr.append(ind_del)
   321       978         4925      5.0      0.1                      if ak < e:
   322       759         3267      4.3      0.1                          indo.append(ind_del)
   323       759         2989      3.9      0.1                          lo += 1
   324                                                               else:
   325       219          945      4.3      0.0                          inde.append(ind_del)
   326       219          842      3.8      0.0                          le += 1
   327                                           
   328       978         3678      3.8      0.1                      lr += 1
   329                                                               #decrement R, delete row ismin and column ismin
   330       978         3751      3.8      0.1                      if ls > 2:
   331       609         3200      5.3      0.1                          ismin += 1
   332       609         3864      6.3      0.1                          R_new = zeros((ls,ls))
   333       609         7418     12.2      0.1                          R_new[0:ismin, 0:ismin] = R[0:ismin, 0:ismin]
   334       609         6971     11.4      0.1                          R_new[ismin:, 0:ismin] = R[ismin+1:,0:ismin]
   335       609         6638     10.9      0.1                          R_new[0:ismin, ismin:] = R[0:ismin, ismin+1:]
   336       609         7273     11.9      0.1                          R_new[ismin:, ismin:] = R[ismin+1:, ismin+1:]
   337       609         4066      6.7      0.1                          betak = zeros(ls)
   338       609         4793      7.9      0.1                          betak[:ismin] = R[ismin, :ismin]
   339       609         5366      8.8      0.1                          betak[ismin:] = R[ismin, ismin+1:]
   340       609        23214     38.1      0.4                          R_new -= outer(betak, betak)/R[ismin,ismin]
   341       609         2596      4.3      0.0                          R = R_new
   342       369         1404      3.8      0.0                      elif ls == 2:
   343       275         2899     10.5      0.1                          R = ones((2, 2))
   344       275         1138      4.1      0.0                          R[1,1] = 0
   345       275         1057      3.8      0.0                          R[0,0] = -1
   346                                                               else:
   347        94          376      4.0      0.0                          R = inf
   348       978         3808      3.9      0.1                      ls -= 1
   349                                           
   350      1452         7203      5.0      0.1                  elif imin == 1:
   351                                                               # delete the elements from X,a and g => add it to the end of X,a,g
   352       709        54318     76.6      1.0                      ind_del = np.asarray(inde)[Ie_plus][iemin]
   353       709         2749      3.9      0.1                      if ls > 0:
   354       615        11492     18.7      0.2                          nk = K_X[ind_del, :][[ind_del] + inds]
   355       615         7241     11.8      0.1                          betak = - R.dot(nk)
   356       615         7558     12.3      0.1                          k = 1 - nk.dot(R).dot(nk)
   357       615         6859     11.2      0.1                          betak1 = ones(ls + 2)
   358       615         3210      5.2      0.1                          betak1[:-1] = betak
   359       615         2429      3.9      0.0                          R_old = R
   360       615        20762     33.8      0.4                          R = 1/k * outer(betak1, betak1)
   361       615         8537     13.9      0.2                          R[:-1,:-1] += R_old
   362                                                               else:
   363        94          937     10.0      0.0                          R = ones((2, 2))
   364        94          387      4.1      0.0                          R[1,1] = 0
   365        94          353      3.8      0.0                          R[0,0] = -1
   366       709         3433      4.8      0.1                      inds.append(ind_del)
   367       709         3200      4.5      0.1                      c_inds = [start_new] + inds
   368       709       198900    280.5      3.8                      indr.remove(ind_del)
   369       709       118347    166.9      2.3                      inde.remove(ind_del)
   370       709         2819      4.0      0.1                      ls += 1
   371       709         2763      3.9      0.1                      lr -= 1
   372       709         2732      3.9      0.1                      le -= 1
   373                                           
   374       743         3587      4.8      0.1                  elif imin == 2: # min = gemin | gomin => move k from r to s
   375                                           
   376                                                               # delete the elements from X,a and g => add it to the end of X,a,g
   377       217        32501    149.8      0.6                      ind_del = np.asarray(indo)[Io_minus][iomin]
   378       217          852      3.9      0.0                      if ls > 0:
   379       217         2510     11.6      0.0                          nk = ones(ls+1)
   380       217         4253     19.6      0.1                          nk[1:] = K_X[ind_del,:][inds]
   381       217         2603     12.0      0.0                          betak = - R.dot(nk)
   382       217         2722     12.5      0.1                          k = 1 - nk.dot(R).dot(nk)
   383       217         2312     10.7      0.0                          betak1 = ones(ls+2)
   384       217         1094      5.0      0.0                          betak1[:-1] = betak
   385       217          855      3.9      0.0                          R_old = R
   386       217         7420     34.2      0.1                          R = 1/k * outer(betak1, betak1)
   387       217         3065     14.1      0.1                          R[:-1,:-1] += R_old
   388                                                               else:
   389                                                                   R = ones((2, 2))
   390                                                                   R[1,1] = 0
   391                                                                   R[0,0] = -1
   392                                           
   393       217        56239    259.2      1.1                      indo.remove(ind_del)
   394       217       105827    487.7      2.0                      indr.remove(ind_del)
   395       217         1006      4.6      0.0                      inds.append(ind_del)
   396       217         1008      4.6      0.0                      c_inds = [start_new] + inds
   397       217          868      4.0      0.0                      lo -= 1
   398       217          836      3.9      0.0                      lr -= 1
   399       217          849      3.9      0.0                      ls += 1
   400       526         2540      4.8      0.0                  elif imin == 3:
   401         4           16      4.0      0.0                      break
   402                                                           else:
   403       522         2088      4.0      0.0                      break
   404      1904         6688      3.5      0.1                  loop_count += 1
   405                                           
   406      1263         5198      4.1      0.1              a[start_new] = ac
   407      1263         5055      4.0      0.1              g[start_new] = gc
   408      1263         6237      4.9      0.1              if ac < e:
   409       737         3496      4.7      0.1                  indr.append(start_new)
   410       737         3263      4.4      0.1                  indo.append(start_new)
   411       737         2941      4.0      0.1                  lr += 1
   412       737         2551      3.5      0.0                  lo += 1
   413       526         2759      5.2      0.1              elif ac > C - e:
   414       522         2628      5.0      0.1                  indr.append(start_new)
   415       522         2361      4.5      0.0                  inde.append(start_new)
   416       522         2165      4.1      0.0                  lr += 1
   417       522         1883      3.6      0.0                  le += 1
   418                                                       else:
   419         4           18      4.5      0.0                  inds.append(start_new)
   420         4           17      4.2      0.0                  g[start_new] = 0
   421         4           20      5.0      0.0                  if len(inds) == 1:
   422                                                               R = ones((2, 2))
   423                                                               R[1,1] = 0
   424                                                               R[0,0] = -1
   425                                                           else:
   426         4           24      6.0      0.0                      if R.shape[0] != len(inds) + 1:
   427         4           46     11.5      0.0                          nk = ones(ls+1)
   428         4           78     19.5      0.0                          nk[1:] = K_X[start_new, :][inds[:-1]]
   429         4           49     12.2      0.0                          betak = - R.dot(nk)
   430         4           51     12.8      0.0                          k = 1 - nk.dot(R).dot(nk)
   431         4           43     10.8      0.0                          betak1 = ones(ls + 2)
   432         4           21      5.2      0.0                          betak1[:-1] = betak
   433         4           15      3.8      0.0                          R_old = R
   434         4          140     35.0      0.0                          R = 1/k * outer(betak1, betak1)
   435         4           56     14.0      0.0                          R[:-1,:-1] += R_old
   436                                           
   437         4           14      3.5      0.0                  ls += 1
   438                                                    # update X, a
   439         1           15     15.0      0.0          self._data.set_X(X)
   440         1            8      8.0      0.0          self._data.set_alpha(a)
   441         1            7      7.0      0.0          self._data.set_C(C)
   442         1            8      8.0      0.0          self._data.set_K_X(K_X)
   443         1          603    603.0      0.0          print self.rho()


*** PROFILER RESULTS ***
incremental_ocsvm (../evaluation_tmp.py:185)
function called 1 times

         68473 function calls in 6.530 seconds

   Ordered by: cumulative time, internal time, call count
   List reduced from 150 to 40 due to restriction <40>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    6.530    6.530 evaluation_tmp.py:185(incremental_ocsvm)
        1    0.000    0.000    6.115    6.115 line_profiler.py:95(wrapper)
        1    5.047    5.047    6.115    6.115 ocsvm.py:97(increment)
     2830    0.472    0.000    0.472    0.000 {method 'remove' of 'list' objects}
        1    0.000    0.000    0.415    0.415 ocsvm.py:35(fit)
        1    0.008    0.008    0.414    0.414 ocsvm.py:62(alpha)
        1    0.000    0.000    0.394    0.394 coneprog.py:4159(qp)
        1    0.005    0.005    0.394    0.394 coneprog.py:1441(coneqp)
       16    0.000    0.000    0.341    0.021 coneprog.py:1984(kktsolver)
       16    0.011    0.001    0.341    0.021 misc.py:1389(factor)
        2    0.000    0.000    0.225    0.113 ocsvm.py:58(gram)
        2    0.000    0.000    0.225    0.113 pairwise.py:1164(pairwise_kernels)
        2    0.000    0.000    0.225    0.112 pairwise.py:949(_parallel_pairwise)
        2    0.132    0.066    0.225    0.112 pairwise.py:740(rbf_kernel)
       16    0.199    0.012    0.199    0.012 {cvxopt.base.syrk}
     9390    0.164    0.000    0.164    0.000 {min}
        2    0.034    0.017    0.093    0.046 pairwise.py:136(euclidean_distances)
     3824    0.007    0.000    0.083    0.000 numeric.py:167(asarray)
       16    0.077    0.005    0.077    0.005 {cvxopt.base.gemm}
     3852    0.076    0.000    0.076    0.000 {numpy.core.multiarray.array}
     8446    0.060    0.000    0.060    0.000 {method 'dot' of 'numpy.ndarray' objects}
        2    0.000    0.000    0.058    0.029 extmath.py:171(safe_sparse_dot)
        2    0.000    0.000    0.058    0.029 extmath.py:129(fast_dot)
        2    0.057    0.029    0.058    0.029 extmath.py:97(_fast_dot)
       32    0.053    0.002    0.053    0.002 {cvxopt.lapack.potrf}
     1445    0.022    0.000    0.032    0.000 numeric.py:740(outer)
      188    0.027    0.000    0.027    0.000 {cvxopt.base.gemv}
       30    0.000    0.000    0.027    0.001 coneprog.py:2333(f4)
       31    0.000    0.000    0.026    0.001 misc.py:1489(solve)
       30    0.000    0.000    0.026    0.001 coneprog.py:2291(f4_no_ir)
     3767    0.012    0.000    0.025    0.000 numeric.py:1791(ones)
     9331    0.019    0.000    0.019    0.000 {numpy.core.multiarray.where}
       32    0.000    0.000    0.009    0.000 coneprog.py:1900(fG)
       32    0.000    0.000    0.009    0.000 misc.py:801(sgemv)
     3770    0.009    0.000    0.009    0.000 {numpy.core.multiarray.empty}
       62    0.008    0.000    0.008    0.000 {cvxopt.blas.trsv}
     3767    0.004    0.000    0.004    0.000 {method 'fill' of 'numpy.ndarray' objects}
        2    0.000    0.000    0.003    0.002 shape_base.py:177(vstack)
       16    0.000    0.000    0.003    0.000 coneprog.py:1847(fP)
       16    0.003    0.000    0.003    0.000 {cvxopt.base.symv}



*** PROFILER RESULTS ***
cvxopt_ocsvm (../evaluation_tmp.py:181)
function called 1 times

         3248 function calls in 25.104 seconds

   Ordered by: cumulative time, internal time, call count
   List reduced from 123 to 40 due to restriction <40>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000   25.104   25.104 evaluation_tmp.py:181(cvxopt_ocsvm)
        1    0.007    0.007   25.104   25.104 ocsvm.py:35(fit)
        1    0.310    0.310   25.074   25.074 ocsvm.py:62(alpha)
        1    0.002    0.002   24.391   24.391 coneprog.py:4159(qp)
        1    0.009    0.009   24.389   24.389 coneprog.py:1441(coneqp)
       16    0.000    0.000   23.384    1.462 coneprog.py:1984(kktsolver)
       16    0.201    0.013   23.384    1.462 misc.py:1389(factor)
       16   16.354    1.022   16.354    1.022 {cvxopt.base.syrk}
       16    3.604    0.225    3.604    0.225 {cvxopt.base.gemm}
       32    3.136    0.098    3.136    0.098 {cvxopt.lapack.potrf}
      188    0.752    0.004    0.752    0.004 {cvxopt.base.gemv}
       31    0.001    0.000    0.668    0.022 misc.py:1489(solve)
       30    0.000    0.000    0.650    0.022 coneprog.py:2333(f4)
       30    0.000    0.000    0.649    0.022 coneprog.py:2291(f4_no_ir)
       32    0.000    0.000    0.254    0.008 coneprog.py:1900(fG)
       32    0.001    0.000    0.254    0.008 misc.py:801(sgemv)
        2    0.000    0.000    0.227    0.114 ocsvm.py:58(gram)
        2    0.000    0.000    0.227    0.114 pairwise.py:1164(pairwise_kernels)
        2    0.000    0.000    0.227    0.114 pairwise.py:949(_parallel_pairwise)
        2    0.139    0.070    0.227    0.114 pairwise.py:740(rbf_kernel)
       62    0.167    0.003    0.167    0.003 {cvxopt.blas.trsv}
        2    0.000    0.000    0.147    0.073 shape_base.py:177(vstack)
        2    0.146    0.073    0.146    0.073 {numpy.core.multiarray.concatenate}
        2    0.040    0.020    0.088    0.044 pairwise.py:136(euclidean_distances)
       16    0.087    0.005    0.087    0.005 {cvxopt.blas.trsm}
       16    0.000    0.000    0.053    0.003 coneprog.py:1847(fP)
       16    0.053    0.003    0.053    0.003 {cvxopt.base.symv}
        2    0.000    0.000    0.047    0.024 extmath.py:171(safe_sparse_dot)
        2    0.000    0.000    0.047    0.024 extmath.py:129(fast_dot)
        2    0.047    0.023    0.047    0.024 extmath.py:97(_fast_dot)
        1    0.000    0.000    0.024    0.024 ocsvm.py:45(rho)
        2    0.000    0.000    0.021    0.011 twodim_base.py:220(diag)
        4    0.021    0.005    0.021    0.005 {numpy.core.multiarray.zeros}
       15    0.005    0.000    0.008    0.001 misc.py:422(update_scaling)
       90    0.003    0.000    0.003    0.000 {cvxopt.misc_solvers.scale2}
       91    0.002    0.000    0.002    0.000 {cvxopt.misc_solvers.scale}
      110    0.002    0.000    0.002    0.000 {range}
       32    0.001    0.000    0.001    0.000 {cvxopt.base.sqrt}
      275    0.001    0.000    0.001    0.000 {cvxopt.blas.axpy}
      123    0.001    0.000    0.001    0.000 {cvxopt.blas.copy}



*** PROFILER RESULTS ***
sklearn_ocsvm (../evaluation_tmp.py:177)
function called 1 times

         61 function calls in 0.078 seconds

   Ordered by: cumulative time, internal time, call count

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.078    0.078 evaluation_tmp.py:177(sklearn_ocsvm)
        1    0.000    0.000    0.078    0.078 classes.py:941(fit)
        1    0.000    0.000    0.078    0.078 base.py:99(fit)
        1    0.000    0.000    0.078    0.078 base.py:211(_dense_fit)
        1    0.077    0.077    0.077    0.077 {sklearn.svm.libsvm.fit}
        1    0.000    0.000    0.000    0.000 validation.py:268(check_array)
        1    0.000    0.000    0.000    0.000 validation.py:43(_assert_all_finite)
        1    0.000    0.000    0.000    0.000 {method 'sum' of 'numpy.ndarray' objects}
        2    0.000    0.000    0.000    0.000 base.py:553(isspmatrix)
        5    0.000    0.000    0.000    0.000 {numpy.core.multiarray.array}
        2    0.000    0.000    0.000    0.000 sputils.py:116(_isinstance)
        2    0.000    0.000    0.000    0.000 numeric.py:167(asarray)
        1    0.000    0.000    0.000    0.000 base.py:193(_validate_targets)
        1    0.000    0.000    0.000    0.000 validation.py:126(_shape_repr)
        1    0.000    0.000    0.000    0.000 {method 'randint' of 'mtrand.RandomState' objects}
        1    0.000    0.000    0.000    0.000 numeric.py:1791(ones)
        1    0.000    0.000    0.000    0.000 shape_base.py:58(atleast_2d)
        1    0.000    0.000    0.000    0.000 {method 'join' of 'str' objects}
        2    0.000    0.000    0.000    0.000 {numpy.core.multiarray.empty}
        1    0.000    0.000    0.000    0.000 getlimits.py:234(__init__)
        3    0.000    0.000    0.000    0.000 validation.py:153(<genexpr>)
        2    0.000    0.000    0.000    0.000 numeric.py:237(asanyarray)
        1    0.000    0.000    0.000    0.000 validation.py:105(_num_samples)
        1    0.000    0.000    0.000    0.000 validation.py:503(check_random_state)
        4    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}
        1    0.000    0.000    0.000    0.000 {method 'fill' of 'numpy.ndarray' objects}
        1    0.000    0.000    0.000    0.000 {method 'copy' of 'numpy.ndarray' objects}
        1    0.000    0.000    0.000    0.000 {sklearn.svm.libsvm.set_verbosity_wrap}
        1    0.000    0.000    0.000    0.000 getlimits.py:259(max)
        6    0.000    0.000    0.000    0.000 {len}
        3    0.000    0.000    0.000    0.000 {hasattr}
        1    0.000    0.000    0.000    0.000 base.py:203(_warn_from_fit_status)
        3    0.000    0.000    0.000    0.000 {isinstance}
        1    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'index' of 'list' objects}
        2    0.000    0.000    0.000    0.000 {callable}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        0    0.000             0.000          profile:0(profiler)


